"use strict";(globalThis.webpackChunkbook=globalThis.webpackChunkbook||[]).push([[473],{2927(e,n,o){o.r(n),o.d(n,{assets:()=>a,contentTitle:()=>s,default:()=>p,frontMatter:()=>l,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"part-4-perception-and-control/chapter-8-control-pipelines","title":"Chapter 8: Control Pipelines","description":"Effective robotic control is the bridge between perceiving the world and acting upon it. This chapter delves into the fundamental concepts of robotic control pipelines, covering how robots execute motions, maintain stability, and interact with their environment. We will also explore advanced tools like MoveIt 2 for complex motion planning.","source":"@site/docs/part-4-perception-and-control/chapter-8-control-pipelines.md","sourceDirName":"part-4-perception-and-control","slug":"/part-4-perception-and-control/chapter-8-control-pipelines","permalink":"/Hackathon_Physical_AI_-Humanoid_Robotics_Book/docs/part-4-perception-and-control/chapter-8-control-pipelines","draft":false,"unlisted":false,"editUrl":"https://github.com/your-org/humanoid-robotics-book/tree/main/docs/part-4-perception-and-control/chapter-8-control-pipelines.md","tags":[],"version":"current","sidebarPosition":8,"frontMatter":{"sidebar_position":8},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 7: Perception with NVIDIA Isaac","permalink":"/Hackathon_Physical_AI_-Humanoid_Robotics_Book/docs/part-4-perception-and-control/chapter-7-nvidia-isaac-for-perception"},"next":{"title":"Chapter 9: Connecting LLMs to ROS 2","permalink":"/Hackathon_Physical_AI_-Humanoid_Robotics_Book/docs/part-5-vision-language-action/chapter-9-connecting-llms-to-ros"}}');var r=o(4848),i=o(8453);const l={sidebar_position:8},s="Chapter 8: Control Pipelines",a={},c=[{value:"The Control Loop",id:"the-control-loop",level:2},{value:"Motion Planning with MoveIt 2",id:"motion-planning-with-moveit-2",level:2},{value:"Key Components of MoveIt 2:",id:"key-components-of-moveit-2",level:3},{value:"Implementing a Simple Controller",id:"implementing-a-simple-controller",level:2},{value:"Example: PID Controller for a Joint",id:"example-pid-controller-for-a-joint",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"chapter-8-control-pipelines",children:"Chapter 8: Control Pipelines"})}),"\n",(0,r.jsx)(n.p,{children:"Effective robotic control is the bridge between perceiving the world and acting upon it. This chapter delves into the fundamental concepts of robotic control pipelines, covering how robots execute motions, maintain stability, and interact with their environment. We will also explore advanced tools like MoveIt 2 for complex motion planning."}),"\n",(0,r.jsx)(n.h2,{id:"the-control-loop",children:"The Control Loop"}),"\n",(0,r.jsx)(n.p,{children:"At the heart of any robotic system is the control loop, a continuous process of sensing, planning, and acting."}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sensing"}),": Obtaining data from sensors (e.g., joint encoders, IMUs, cameras) about the robot's current state and environment."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"State Estimation"}),": Fusing sensor data to create an accurate understanding of the robot's position, velocity, and orientation."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Planning"}),": Generating a desired trajectory or sequence of actions to achieve a goal, often taking into account obstacles and robot kinematics/dynamics."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Actuation"}),": Sending commands to the robot's motors (actuators) to execute the planned motion."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"motion-planning-with-moveit-2",children:"Motion Planning with MoveIt 2"}),"\n",(0,r.jsx)(n.p,{children:"MoveIt 2 is the most widely used software for mobile manipulation and motion planning in ROS 2. It provides an easy-to-use framework for complex tasks such as:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Kinematics"}),": Solving forward and inverse kinematics for robotic arms."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Collision Avoidance"}),": Planning paths that avoid obstacles in the environment."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Trajectory Generation"}),": Creating smooth and safe trajectories for robot movements."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Execution"}),": Interfacing with robot controllers to execute the planned motions."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"key-components-of-moveit-2",children:"Key Components of MoveIt 2:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"MoveGroup Interface"}),": A high-level C++ or Python interface for planning and executing motions."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Planning Scene Monitor"}),": Keeps track of the robot's state and the environment, including obstacles."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Motion Planners"}),": Various algorithms (e.g., OMPL, STOMP) to find collision-free paths."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Controllers"}),": Interfaces with the low-level joint controllers of the robot."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"implementing-a-simple-controller",children:"Implementing a Simple Controller"}),"\n",(0,r.jsx)(n.p,{children:"While MoveIt 2 handles high-level planning, low-level joint control often involves PID (Proportional-Integral-Derivative) controllers or more advanced techniques."}),"\n",(0,r.jsx)(n.h3,{id:"example-pid-controller-for-a-joint",children:"Example: PID Controller for a Joint"}),"\n",(0,r.jsx)(n.p,{children:"A PID controller adjusts a control output based on the error between a desired setpoint and a measured process variable."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# Conceptual PID controller in Python\r\nclass PIDController:\r\n    def __init__(self, kp, ki, kd):\r\n        self.kp = kp\r\n        self.ki = ki\r\n        self.kd = kd\r\n        self.prev_error = 0\r\n        self.integral = 0\r\n\r\n    def compute(self, setpoint, measured_value, dt):\r\n        error = setpoint - measured_value\r\n        self.integral += error * dt\r\n        derivative = (error - self.prev_error) / dt\r\n        output = self.kp * error + self.ki * self.integral + self.kd * derivative\r\n        self.prev_error = error\r\n        return output\r\n\r\n# In a ROS 2 node, you would read joint state, compute PID output, and publish joint commands.\n"})})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453(e,n,o){o.d(n,{R:()=>l,x:()=>s});var t=o(6540);const r={},i=t.createContext(r);function l(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);